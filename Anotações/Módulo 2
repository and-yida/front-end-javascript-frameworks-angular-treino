DATA BINDING

Como a maioria dos sites hoje em dia não é estática, os dados são fornecidos por um servidor backend. Os dados são utilizados para exibir dinamicamente conteúdo ou atualizar conteúdo no site.
O template viabiliza o meio de comunicação com o DOM. Os dados fluem do backend para a aplicação web até o DOM. O template requer dados para ser disponibilizado através do componente. Além disso, os eventos de interação do usuário com o DOM são enviados de volta à aplicação.
Já vimos exemplo de como o Angular nos dá suporte nessa questão, permitindo o uso de propriedades dos componentes no template.
Chama-se data binding o mecanismo de coordenação do fluxo de informação entre o template e o DOM, ou, no caso do Angular, podemos dizer entre o componente e a propriedade no DOM.
Na perspectiva do componente, uma propriedade ou método é disponibilizado ao template ou é invocado a partir do DOM. Na perspectiva do template, há informações que precisam ser renderizadas no DOM ou serem tomadas do DOM e enviadas de volta ao componente.
Quatro formas de data binding com Angular:
    {{ value }} : um valor do componente é utilizado no template;
    [property] = "value" : uma propriedade associada a uma tag [], passada como valor para uma propriedade do componente;
    (event)="handler" : evento gerado no DOM gera uma chamada para um manipulador ou método do componente;
    [(ngModel)]="property" : qualquer mudança no DOM será refletida na propriedade do componente, e qualquer mudança na propriedade vai ser refletida no DOM.
Binding targets são propriedades declaradas à esquerda da declaração, enquanto binding sources são declaradas à direita.
Definir propriedades de targets associados a selectors de componente é uma forma de passar informação a um componente, ou enviar informação de um componente a outro. Utilizamos input e output decorators. Ex.: @Input() nome: Nome; @Output() event = new EventEmitter<Nome>();

Neste projeto, implementamos a funcionalidade do usuário poder clicar no prato e poder ver informações sobre ele.

Existe uma classe dish na qual introduzimos a classe dos objetos "dish" (os pratos), com seus parâmetros: preço, comentário, descrição, etc. Essa classe centralizará todas as chamadas à classe.
Criamos um outra classe dishes para passar os valores de cada objeto dish, organizados sob a forma de array.
    export const DISHES: Dish[] = [
    {
        id: '0',
        ...
        }
    {
        id: '1',
        ...
    }
    
A propriedade input está ligada a uma propriedade DOM no template. Atualiza o template com o valor da propriedade no DOM.
Usando Input para compartilhar dados entre componentes: no componente dishdetail, entramos com a propriedade dish que recebe os objetos de Dish.
    @Input() dish: Dish;
    // o item dish advém da classe Dish, importada do arquivo dish.ts
No componente menu, a propriedade "dishes" recebe o valor de cada objeto dentro da classe Dish, e cujos valores foram passados na classe DISHES.
    dishes: Dish[] = DISHES;

No template do componente menu, para permitir que o click no objeto prato desencadeie um evento, utilizamos no grid de pratos o handler:
    <mat-grid-tile *ngFor="let dish of dishes" (click)="onSelect(dish)">
    //onSelect(dish) define o evento relativo a quando um item (dish) é clicado
O template no componente dishdetail vêm logo abaixo do grid:
    <app-dishdetail [dish] = "selectedDish"></app-dishdetail>
    //o parâmetro passado dentro do selector diz que a propriedade [dish] é passado como valor da propriedade no componente "selectedDish"
Para garantir a relação entre o objeto clicado e suas informações a serem exibidas, incluímos no componente menu:
    selectedDish!: Dish;
    ...
    onSelect(dish: Dish) {
    this.selectedDish = dish;
  }

    //selectedDish vai receber o valor do atual dish clicado


MODEL VIEW CONTROLLER FRAMEWORK

MVC e MVVM frameworks
Design patterns são padrões de projetos que referem-se a soluções bem documentadas para problemas recorrentes. Soluções para problemas recorrentes resolvidos por meio de software são os chamados software design patterns.
Um dos padrões de engenharia de software, um padrão de arquitetura - software engineering architecture pattern -, prescreve isolar o domínio lógico da interface do usuário. Há uma separação entre: view, model e controller. Isso permite desenvolvimento, teste e manutenção independentes.
Uma aplicação pode ser separada em três partes: model, view e controller.

MVC (Model-View-Controller)
Uma abordagem baseada em MVC consiste na seguinte divisão entre model, view e controller.
Model:
    gerencia o comportamento dos dados da aplicação;
    responde a requisições sobre o estado de informações;
    responde a instruções para mudar os estados;
    em sistemas controlados por eventos, o model notifica o view quando uma informação é alterada.
View:
    renderiza o model para uma forma passível de interação (elemento de interface);
    múltiplas views podem existir para um mesmo model, isto é, diferentes maneiras de apresentar a informação para o usuário;
    a janela de exibição possui correspondência com o tamanho do display;
Controller:
    recebe entradas do usuário e inicia chamadas aos objetos do model;
    instrui o model e a janela de exibição sobre ações baseadas na entrada a serem tomadas;

MVVM (Model View View-Model)
Na abordagem MVVM, o model representa a lógica e os dados; o view-model deriva do model e compreende a parte da informação necessária à renderização de uma view; view-model e view representam a apresentação e a lógica de apresentação.
View model é uma abstração da view, compreendendo as propriedades públicas e os comandos disponíveis, e dispõe declarative data binding (ligação de dados declarativa).
A forma como o Angular implementa os componentes e os templates pode ser vista como um modelo de abordagem MVVM.


SERVICES

Quando criamos um componente no Angular, convém deixarmos as classes de componente o mais exuto possível. O componente deve concentrar a tarefa de agir como um mediador entre a exibição (view) e a lógica (business logic) - ou, entre a view e o model, em outras palavras.
Tarefas como buscar dados, validar entradas do usuário e informações de logging devem ser delegadas ao service. O service, portanto, é uma funcionalidade que provê esse tipo de recurso para que as classes de componente executem seu próprio trabalho. Ao service cabe, portanto, boa parte da lógica da aplicação.
No Angular, temos a seguinte relação entre componente e template. O template atua renderizando a exibição (view) do componente, e o componente administra as propriedades e métodos que vão ser acessados pelo template para exibir a informação.
O service, por sua vez, atua no componente, sendo injetado neste para suprimento de alguns recursos de que necessita o componente.
Os services estão relacionadas à: injeção de dependência, promessas e JavaScript reativo.


DEPENDENCY INJECTION

Injeção de dependência é um padrão de projeto para resolver questões de dependência. É útil quando há objetos que dependem de outros objetos.
Dependência é quando um objeto depende de outro objeto. Injeção consiste em passar uma dependência para um objeto dependente, o que o permite utilizar-se do que necessita. O objeto dependente não precisa lidar com como o primeiro objeto é implementado ou criado.
Há três formas de um objeto acessar o outro:
    criar o objeto dependente utilizando novo operador;
    declarar o objeto dependente como variável global, e rastrear a dependência utilizando essa variável;
    passar a dependência onde ela é necessária, sendo ela injetada para nós.
A terceira opção, da dependência, é mais flexível e precisa de menos código.
A DI envolve quatro funções:
    service: do qual nós fazemos uso;
    client: aquilo que é dependente, como o caso do componente;
    interface: sobre como fazer uso do service;
    injector: a entidade responsável por injetar o objeto.
Com Angular, podemos escrever a lógica no objeto independente e simplesmente injetá-lo onde for necessário. O subsistema de injeção do Angular é responsável por tornar possível todas as operações envolvidas.
