DIALOGS

O Angular fornece o Dialogue Component, que permite sobrepor conteúdo sobre a view atual.
Para criar uma caixa de diálogo, geramos um novo componente para ela. No arquivo ts, devemos importar o module Mat Dialog.
    import {MatDialog, MatDialogRef} from '@angular/material/dialog';

Em nosso projeto, criamos um componente de login em toolbar. No template:
    <mat-toolbar color="primary">
        Login
    <span class="flex-spacer"></span>
    <button mat-button mat-dialog-close>&times;</button>
    </mat-toolbar>
    //Com a classe "flex-spacer", abrimos espaço entre os conteúdos anteriores e posteriores. O elemento declarado irá ser empurrado o mais à direita possível da tela.
No app.module.ts, também incluir o MatDialog. Além disso, devemos declarar o componente login como entrada.
    entryComponents: [
    LoginComponent
    ],

O header também precisa ser atualizado. É aí que o diálogo de Login será inserido.
    import { MatDialog, MatDialogRef } from '@angular/material/dialog';
    import { LoginComponent } from '../login/login.component';
    ...
    constructor(public dialog: MatDialog ) { }

Inserimos uma função que, quando invocada, deve desencadear a exibição do componente login.
    openLoginForm() {
        this.dialog.open(LoginComponent, {width: '500px', height: '450px'});
    }


ANGULAR TEMPLATE-DRIVEN FORMS

Angular suporta dois tipos de formulários: formulário guiado por template e formulário reativo.
Formulários são amplamente utilizados para permitir usuários introduzir informação no site ou aplicação.
Angular fornece: ligação de dados de mão dupla, rastreamento de alterações e validação e tratamento de erros.

Template-driven forms
Neste tipo, usamos a sintaxe do Angular para template para construir um formulário, utilizando elementos de formulário e diretivas específicas. Fazemos uso da diretiva ngModel.
Two-way data binding vincula informação do formulário e variáveis JS de objetos em classes.
Devemos importar os modules de formulários.
    import { MatFormFieldModule } from '@angular/material/form-field';
    //permite agrupar elementos de formulário
    import { MatInputModule } from '@angular/material/input';
    //permite criar um campo de entrada
    import { MatCheckboxModule } from '@angular/material/checkbox';
    //permite criar checkbox
    import { FormsModule } from '@angular/forms';

Em nosso projeto, no login.html adicionamos
    <p>{{ user | json }}</p>
    //forma de exibir alterções enquanto digitamos informação no formulário, refletidas no estado do formulário

Criamos o forms com:
    <form novalidate (ngSubmit)="onSubmit()">
    //novalidate, pois a validação não será feita através de HTML padrão, deixaremos a validação com o Angular
        <mat-dialog-content>
        //colocamos o formulário em uma caixa de diálogo
            <p>
            <mat-form-field>
            //mat-form-field agrupa elementos relacionados que serão usados em conjunto
                <input matInput placeholder="Username" type="text" [(ngModel)]="user.username" name="username">
                //[(ngModel)] garante o two-way data binding
                //user será um objeto JS, que vai conter a propriedade "username" e vai rastrear o valor entrado neste campo de entrada do formulário
            </mat-form-field>
            <mat-form-field>
                <input matInput placeholder="Password" type="password" [(ngModel)]="user.password" name="password">
            </mat-form-field>
            <mat-checkbox [(ngModel)]="user.remember" name="remember">Remember Me</mat-checkbox>
            //quando selecionado, esse botão informa que usuário e a senha devem ser salvas na aplicação
            </p>

Adicionamos botões que irão performar ações.
    <mat-dialog-actions>
        <span class="flex-spacer"></span>
        <button mat-button mat-dialog-close>Cancel</button>
        <button type="submit" mat-button class="background-primary text-floral-white">Login</button>
    </mat-dialog-actions>

No arquivo ts do componente login, criamos um objeto "user" com os propriedades "username", "password" e "remember". Dessa forma, conseguimos atrelar essas três propriedades aos elementos do formulário no template.
    user = {username: '', password: '', remember: false};
    //username e password são passados vazios
No construtor, devemos indicar o dialog ref.
    constructor(public dialogRef: MatDialogRef<LoginComponent>) { }


TEMPLATE-DRIVEN FORM VALIDATION

É possível fazer validação no lado do cliente.
Devemos desativar a validação de formulários do HMTL5, para transferir essa tarefa ao Angular: <form novalidate>
Utilizamos variáveis de referência de template (como "username" e "login form") que podem ser utilizadas no template para referenciar os campos do formulário
    <input...#username="ngModel"...>
    //#variável que referencia um campo do formulário = "ngModel"
Os controles de estado são adicionados às variáveis para fazer validações.
    .pristine : verdadeiro se o campo/formulário não foi alterado;
    .dirty : contrário de pristine;
    .valid : verdadeiro se o campo/formulário é válido;
    .invalid : contrário de valid.

Exemplos de validação
Desabilitar botão de submeter se o estado do formulário é inválido.
    <button type="submit" ...
        [disabled]="loginForm.form.invalid">Login</button>
Exibir erro caso a entrada do usuário não estiver de acordo com as regras especificadas para aquele campo.
    <mat-form-field>
        <input matInput placeholder="Username" type="text" [(ngModel)]="user.name"
        name="username" #username="ngModel" required>
        <mat-error *mgIf="username.erros?.required">Username is required</mat-error>
    </mat-form-field>

Em nosso projeto, adicionamos a variável de template para rastrear o estado do formulário.
    <form ...  #loginForm="ngForm" ...>
Para os campos:
    <input matInput... #username="ngModel" required>
    //se o campo estiver vazio, o erro sobre "required" irá aparecer (pois o preenchimento da campo é obrigatório)
Deabilitamos o botão de login (submit) quando o estado do formulário for inválido.
    <button type="submit" mat-button ... [disabled]="loginForm.form.invalid">
Para especificar um tipo de erro, incluímos em cada campo "mat-error".
    <mat-error *ngIf="password.errors?.required">Password is required</mat-error>
    //o erro está sobre "required", isto é, se o usuário não preenche o campo de senha.


ANGULAR REACTIVE FORMS

Nos formulários reativos, há gerenciamento explícito de dados fluindo entre um model de dados que não pertence a UI (back-end)e um modelo de formulário de UI.
Criamos uma árvore de objetos de controle do formulário dentro da classe componente. Dessa forma, criamos a estrutura do formulário no componente e vinculamos esta estrutura aos controles do formulário no âmbito do template.
Testagem e validação são mais fáceis nos formulários reativos do que nos digiridos por template, pois, neste último caso, boa parte da estrutura está no código do template.
Os valores advindos dos elementos do formulário são imediamente disponibilizados e sincronizados com o código TypeScript.
O Angular fornece algumas classes como:
    FormControl: dispõe controles individuais que rastreiam valores e estados de validação;
    FormGroup: organiza FormControls em um grupo;
    AbstractControl: dispõe classe que funciona como base abstrata para o os FormControls;
    FormArray: define vetores de instâncias de AbstractControls.
O FormBuilder permite criar formulários com TS e os vincular aos controles no template.
Ao criar o model de formulário no código TS e preenchê-lo, é necessário que o model de dados seja mapeado para o model de formulário a fim de preencher os valores.
O model de formulário e o model de dados são separados. Alterações realizadas em elementos do DOM no formulário são direcionadas ao model de formúlario, ao passo que
os dados do formulário devem ser refletidos de volta ao model de dados (no back-end).
Quando pegamos o model de dados do back-end, os valores são passados ou mapeados para o model de formulário. Há duas formas de preencher o model de formulário a partir do model de dados:
    setValue(): método que atribui valor a todo controle a partir do model de dados de uma só vez;
    patchValue(): método que atualiza apenas alguns valores dos controles no formulário.

Em nosso projeto, importamos o module de ReactiveForms e outros no app.module.
    import { ReactiveFormsModule } from '@angular/forms';
    import { MatSelectModule } from '@angular/material/select';
    //habilita selecionar elemento
    import { MatSlideToggleModule } from '@angular/material/slide-toggle';
    //habilita botão slide toggle

    imports: [
    . . .
    MatSelectModule,
    MatSlideToggleModule,
    ReactiveFormsModule
  ],

Criamos um arquivo feedback.ts que representa o model de dados correspondente ao model de formulário que utilizaremos na aplicação. Aqui consta uma classe com os atributos cujos valores esperamos receber dos usuários no formulário.
    export class Feedback {
      firstname: string;
      lastname: string;
      telnum: number;
      email: string;
      agree: boolean;
      contacttype: string;
      message: string;
    };
    export const ContactType = ['None', 'Tel', 'Email'];
O intuito é criar um formulário de feedback dos clientes.

No componente contact, onde o formulário será inserido, importamos os modules necessários e também as classes que criamos.
    import { FormBuilder, FormGroup, Validators } from '@angular/forms';
    import { Feedback, ContactType } from '../shared/feedback';

Declaramos as variáveis:
    feedbackForm: FormGroup;
    //variável do tipo FormGroup - esse será o model de formulário que irá hospedar nosso reactive form
    feedback: Feedback;
    //será o model de dados - posteriormente, pode ser atrelado ao lado do servidor
    contactType = ContactType;
    //vetor criado anteriormente

No construtor, temos o FormBuilder
    constructor(private fb: FormBuilder) {
        this.createForm();
    }
    //o método createForm será invocado através do construtor, e ele próprio criará o formulário de fato

    createForm() {
      this.feedbackForm = this.fb.group({
        firstname: '',
        lastname: '',
        telnum: 0,
        email: '',
        agree: false,
        contacttype: 'None',
        message: ''
      });
    }
    //utilizamos do FormBuilder para criar o feedbackForm. fornece um método chamado "group" que permite criar um grupo de controles de formulário.

Criamos um método para permitir a submissão no formulário. Adquirimos os valores do model de formulário e vinculamos ao model de dados, e como os dois, neste caso, têm a mesma estrutura, podemos facilmente pegar esses valores.
    onSubmit() {
        this.feedback = this.feedbackForm.value;
        this.feedbackForm.reset();
        //o formulário é resetado depois de submetido
    }

Agora mapeamos esses elementos dentro do template. No html de contact, criamos um div para o formulário:
    <form novalidate [formGroup]="feedbackForm" (ngSubmit)="onSubmit()">
    //o método "onSubmit()" é invocado quando da submissão do formulário
    //formGroup vincula o template aqui e o model do formulário em TS
Os campos do formulário, como exemplo:
    <mat-form-field class="half-width">
          <input matInput formControlName="firstname" placeholder="First Name" type="text">
    </mat-form-field>
    //o campo recebe um input com matInput, do tipo formControlName, vinculado à propriedade que declaramos no model de formulário como "firstname"
Com o FormBuilder, precisamos somente atrelar os nomes dos controles de formulário às propriedades da classe utilizada como model de dados.

Adicionamos um botão do tipo slide toggle, que admite os estados selecionado ou não selecionado (valores booleanos).
    <mat-slide-toggle formControlName="agree">May we contact you?</mat-slide-toggle>

Criamos um select element que pemite escolher um dentre os elementos de uma lista. As opções são passadas sob "mat-option", através de interpolação.
    <mat-select placeholder="How?" formControlName="contacttype">
            <mat-option *ngFor="let ctype of contactType" [value]="ctype">
              {{ ctype }}
            </mat-option>
    </mat-select>
    //aqui entra o vetor "contactType", passado como constante, com as opções de formas de contato disponíveis.

Para entrar com o feedback, criamos uma área de texto.
    <mat-form-field class="full-width">
          <textarea matInput formControlName="message" placeholder="Your Feedback" rows=12></textarea>
