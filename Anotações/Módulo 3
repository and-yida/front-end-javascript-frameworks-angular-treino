DIALOGS

O Angular fornece o Dialogue Component, que permite sobrepor conteúdo sobre a view atual.
Para criar uma caixa de diálogo, geramos um novo componente para ela. No arquivo ts, devemos importar o module Mat Dialog.
    import {MatDialog, MatDialogRef} from '@angular/material/dialog';

Em nosso projeto, criamos um componente de login em toolbar. No template:
    <mat-toolbar color="primary">
        Login
    <span class="flex-spacer"></span>
    <button mat-button mat-dialog-close>&times;</button>
    </mat-toolbar>
    //Com a classe "flex-spacer", abrimos espaço entre os conteúdos anteriores e posteriores. O elemento declarado irá ser empurrado o mais à direita possível da tela.
No app.module.ts, também incluir o MatDialog. Além disso, devemos declarar o componente login como entrada.
    entryComponents: [
    LoginComponent
    ],

O header também precisa ser atualizado. É aí que o diálogo de Login será inserido.
    import { MatDialog, MatDialogRef } from '@angular/material/dialog';
    import { LoginComponent } from '../login/login.component';
    ...
    constructor(public dialog: MatDialog ) { }

Inserimos uma função que, quando invocada, deve desencadear a exibição do componente login.
    openLoginForm() {
        this.dialog.open(LoginComponent, {width: '500px', height: '450px'});
    }


ANGULAR TEMPLATE-DRIVEN FORMS

Angular suporta dois tipos de formulários: formulário guiado por template e formulário reativo.
Formulários são amplamente utilizados para permitir usuários introduzir informação no site ou aplicação.
Angular fornece: ligação de dados de mão dupla, rastreamento de alterações e validação e tratamento de erros.

Template-driven forms
Neste tipo, usamos a sintaxe do Angular para template para construir um formulário, utilizando elementos de formulário e diretivas específicas. Fazemos uso da diretiva ngModel.
Two-way data binding vincula informação do formulário e variáveis JS de objetos em classes.
Devemos importar os modules de formulários.
    import { MatFormFieldModule } from '@angular/material/form-field';
    //permite agrupar elementos de formulário
    import { MatInputModule } from '@angular/material/input';
    //permite criar um campo de entrada
    import { MatCheckboxModule } from '@angular/material/checkbox';
    //permite criar checkbox
    import { FormsModule } from '@angular/forms';

Em nosso projeto, no login.html adicionamos
    <p>{{ user | json }}</p>
    //forma de exibir alterções enquanto digitamos informação no formulário, refletidas no estado do formulário

Criamos o forms com:
    <form novalidate (ngSubmit)="onSubmit()">
    //novalidate, pois a validação não será feita através de HTML padrão, deixaremos a validação com o Angular
        <mat-dialog-content>
        //colocamos o formulário em uma caixa de diálogo
            <p>
            <mat-form-field>
            //mat-form-field agrupa elementos relacionados que serão usados em conjunto
                <input matInput placeholder="Username" type="text" [(ngModel)]="user.username" name="username">
                //[(ngModel)] garante o two-way data binding
                //user será um objeto JS, que vai conter a propriedade "username" e vai rastrear o valor entrado neste campo de entrada do formulário
            </mat-form-field>
            <mat-form-field>
                <input matInput placeholder="Password" type="password" [(ngModel)]="user.password" name="password">
            </mat-form-field>
            <mat-checkbox [(ngModel)]="user.remember" name="remember">Remember Me</mat-checkbox>
            //quando selecionado, esse botão informa que usuário e a senha devem ser salvas na aplicação
            </p>

Adicionamos botões que irão performar ações.
    <mat-dialog-actions>
        <span class="flex-spacer"></span>
        <button mat-button mat-dialog-close>Cancel</button>
        <button type="submit" mat-button class="background-primary text-floral-white">Login</button>
    </mat-dialog-actions>

No arquivo ts do componente login, criamos um objeto "user" com os propriedades "username", "password" e "remember". Dessa forma, conseguimos atrelar essas três propriedades aos elementos do formulário no template.
    user = {username: '', password: '', remember: false};
    //username e password são passados vazios
No construtor, devemos indicar o dialog ref.
    constructor(public dialogRef: MatDialogRef<LoginComponent>) { }


TEMPLATE-DRIVEN FORM VALIDATION

É possível fazer validação no lado do cliente.
Devemos desativar a validação de formulários do HMTL5, para transferir essa tarefa ao Angular: <form novalidate>
Utilizamos variáveis de referência de template (como "username" e "login form") que podem ser utilizadas no template para referenciar os campos do formulário
    <input...#username="ngModel"...>
    //#variável que referencia um campo do formulário = "ngModel"
Os controles de estado são adicionados às variáveis para fazer validações.
    .pristine : verdadeiro se o campo/formulário não foi alterado;
    .dirty : contrário de pristine;
    .valid : verdadeiro se o campo/formulário é válido;
    .invalid : contrário de valid.

Exemplos de validação
Desabilitar botão de submeter se o estado do formulário é inválido.
    <button type="submit" ...
        [disabled]="loginForm.form.invalid">Login</button>
Exibir erro caso a entrada do usuário não estiver de acordo com as regras especificadas para aquele campo.
    <mat-form-field>
        <input matInput placeholder="Username" type="text" [(ngModel)]="user.name"
        name="username" #username="ngModel" required>
        <mat-error *mgIf="username.erros?.required">Username is required</mat-error>
    </mat-form-field>

Em nosso projeto, adicionamos a variável de template para rastrear o estado do formulário.
    <form ...  #loginForm="ngForm" ...>
Para os campos:
    <input matInput... #username="ngModel" required>
    //se o campo estiver vazio, o erro sobre "required" irá aparecer (pois o preenchimento da campo é obrigatório)
Deabilitamos o botão de login (submit) quando o estado do formulário for inválido.
    <button type="submit" mat-button ... [disabled]="loginForm.form.invalid">
Para especificar um tipo de erro, incluímos em cada campo "mat-error".
    <mat-error *ngIf="password.errors?.required">Password is required</mat-error>
    //o erro está sobre "required", isto é, se o usuário não preenche o campo de senha.


ANGULAR REACTIVE FORMS

Nos formulários reativos, há gerenciamento explícito de dados fluindo entre um model de dados que não pertence a UI (back-end)e um modelo de formulário de UI.
Criamos uma árvore de objetos de controle do formulário dentro da classe componente. Dessa forma, criamos a estrutura do formulário no componente e vinculamos esta estrutura aos controles do formulário no âmbito do template.
Testagem e validação são mais fáceis nos formulários reativos do que nos digiridos por template, pois, neste último caso, boa parte da estrutura está no código do template.
Os valores advindos dos elementos do formulário são imediamente disponibilizados e sincronizados com o código TypeScript.
O Angular fornece algumas classes como:
    FormControl: dispõe controles individuais que rastreiam valores e estados de validação;
    FormGroup: organiza FormControls em um grupo;
    AbstractControl: dispõe classe que funciona como base abstrata para o os FormControls;
    FormArray: define vetores de instâncias de AbstractControls.
O FormBuilder permite criar formulários com TS e os vincular aos controles no template.
Ao criar o model de formulário no código TS e preenchê-lo, é necessário que o model de dados seja mapeado para o model de formulário a fim de preencher os valores.
O model de formulário e o model de dados são separados. Alterações realizadas em elementos do DOM no formulário são direcionadas ao model de formúlario, ao passo que
os dados do formulário devem ser refletidos de volta ao model de dados (no back-end).
Quando pegamos o model de dados do back-end, os valores são passados ou mapeados para o model de formulário. Há duas formas de preencher o model de formulário a partir do model de dados:
    setValue(): método que atribui valor a todo controle a partir do model de dados de uma só vez;
    patchValue(): método que atualiza apenas alguns valores dos controles no formulário.

Em nosso projeto, importamos o module de ReactiveForms e outros no app.module.
    import { ReactiveFormsModule } from '@angular/forms';
    import { MatSelectModule } from '@angular/material/select';
    //habilita selecionar elemento
    import { MatSlideToggleModule } from '@angular/material/slide-toggle';
    //habilita botão slide toggle

    imports: [
    . . .
    MatSelectModule,
    MatSlideToggleModule,
    ReactiveFormsModule
  ],

Criamos um arquivo feedback.ts que representa o model de dados correspondente ao model de formulário que utilizaremos na aplicação. Aqui consta uma classe com os atributos cujos valores esperamos receber dos usuários no formulário.
    export class Feedback {
      firstname: string;
      lastname: string;
      telnum: number;
      email: string;
      agree: boolean;
      contacttype: string;
      message: string;
    };
    export const ContactType = ['None', 'Tel', 'Email'];
O intuito é criar um formulário de feedback dos clientes.

No componente contact, onde o formulário será inserido, importamos os modules necessários e também as classes que criamos.
    import { FormBuilder, FormGroup, Validators } from '@angular/forms';
    import { Feedback, ContactType } from '../shared/feedback';

Declaramos as variáveis:
    feedbackForm: FormGroup;
    //variável do tipo FormGroup - esse será o model de formulário que irá hospedar nosso reactive form
    feedback: Feedback;
    //será o model de dados - posteriormente, pode ser atrelado ao lado do servidor
    contactType = ContactType;
    //vetor criado anteriormente

No construtor, temos o FormBuilder
    constructor(private fb: FormBuilder) {
        this.createForm();
    }
    //o método createForm será invocado através do construtor, e ele próprio criará o formulário de fato

    createForm() {
      this.feedbackForm = this.fb.group({
        firstname: '',
        lastname: '',
        telnum: 0,
        email: '',
        agree: false,
        contacttype: 'None',
        message: ''
      });
    }
    //utilizamos do FormBuilder para criar o feedbackForm. fornece um método chamado "group" que permite criar um grupo de controles de formulário.

Criamos um método para permitir a submissão no formulário. Adquirimos os valores do model de formulário e vinculamos ao model de dados, e como os dois, neste caso, têm a mesma estrutura, podemos facilmente pegar esses valores.
    onSubmit() {
        this.feedback = this.feedbackForm.value;
        this.feedbackForm.reset();
        //o formulário é resetado depois de submetido
    }

Agora mapeamos esses elementos dentro do template. No html de contact, criamos um div para o formulário:
    <form novalidate [formGroup]="feedbackForm" (ngSubmit)="onSubmit()">
    //o método "onSubmit()" é invocado quando da submissão do formulário
    //formGroup vincula o template aqui e o model do formulário em TS
Os campos do formulário, como exemplo:
    <mat-form-field class="half-width">
          <input matInput formControlName="firstname" placeholder="First Name" type="text">
    </mat-form-field>
    //o campo recebe um input com matInput, do tipo formControlName, vinculado à propriedade que declaramos no model de formulário como "firstname"
Com o FormBuilder, precisamos somente atrelar os nomes dos controles de formulário às propriedades da classe utilizada como model de dados.

Adicionamos um botão do tipo slide toggle, que admite os estados selecionado ou não selecionado (valores booleanos).
    <mat-slide-toggle formControlName="agree">May we contact you?</mat-slide-toggle>

Criamos um select element que pemite escolher um dentre os elementos de uma lista. As opções são passadas sob "mat-option", através de interpolação.
    <mat-select placeholder="How?" formControlName="contacttype">
            <mat-option *ngFor="let ctype of contactType" [value]="ctype">
              {{ ctype }}
            </mat-option>
    </mat-select>
    //aqui entra o vetor "contactType", passado como constante, com as opções de formas de contato disponíveis.

Para entrar com o feedback, criamos uma área de texto.
    <mat-form-field class="full-width">
          <textarea matInput formControlName="message" placeholder="Your Feedback" rows=12></textarea>
          
O método para resetar o formulário.
    this.feedbackFormDirective.resetForm();
Importamos o module ViewChild para permitir acessar elementos filhos do DOM no template. Na prática, isso irá garantir que o formulário no template seja de fato resetado.
    import { Component, OnInit, ViewChild } from '@angular/core';
    ...

    export class ContactComponent implements OnInit {
    ...
    @ViewChild('fform') feedbackFormDirective;
    //o formulário pode ser acessível agora a partir da variável de template que demos a ele: 'fform'
No template, adicionamos esse nome ao formulário.
    <form ... #fform="ngForm" ...>

No template, adicionamos ao botão de submit a propriedade de estar desabilitado quando o estado do formulário for inválido.
    <button type="submit" ... [disabled]="feedbackForm.invalid">Submit</button>
Adicionamos mat-error nos campos para os quais queremos usar validação. Ex.:
    <input matInput formControlName="firstname" placeholder="First Name" type="text" required>
        <mat-error *ngIf="feedbackForm.get('firstname').hasError('required') && feedbackForm.get('firstname').touched">First name is required</mat-error>
        //se o campo firstname não tiver nada escrito e tiver sido tocado, haverá erro.


PROMISES

Promises são um mecanismo para computação assíncrona. Na computação assíncrona, quandos enviamos uma requisição, esperamos que os resultados retornem em um momento posterior, e lidamos com o fato de que isso leva certo tempo.
Promise é um representante (proxy) para um valor não necessariamente conhecido quando da criação do promise. Ele assegura que futuramente quando os valores estiveram disponíveis, eles serão entregues.
Primeiramente, a promessa se apresenta no estado pendente. Quando a promessa é solucionada e os resultados são entregues, ele passa ao estado de resolvida ou preenchida. Porém, quando ocorre um erro e a promessa é rejeitada, ela passa ao estado de rejeitada. Quando escrevemos o código, consideramos ambas os casos como possibilidades.
    new Promise (function (resolve, reject) {...});
Exemplo:
    getDishes()
        .then (function(result) {
            ...
        });
        //se a resolução for bem-sucedida, o then é executado

        .catch (function(error) {
            ...
        });
        //se for rejeitado, o catch é executado. aqui entra algum tratamento de erro

Quando formos lidar com Node Js, veremos que promises são utilizadas em callbacks.
Promessas podem ser encadeadas.
Promessas que podem imediamente retornar um resultado, podem ter seus valores apresentados através de:
    Promise.resolve(result)
    Promise.reject(error)

Services geralmente retornam promessas aos componentes quando os componentes chamam os métodos do service. Quando a promessa é resolvida, os componentes então terão os resultados.
Usar as promessas é uma forma de lidar com os atrasos no processo de obter e entregar dados do servidor.

Em nosso projeto, reconfiguramos os services para incluírem promessas. No service dish.service, o método getDishes foi reconfigurado para retornar uma promessa:
    getDishes(): Promise<Dish[]> {
    return Promise.resolve(DISHES);
    }
    //o método retorna uma promise do tipo vetor de objetos dish caso a promise seja resolvida com sucesso
    //esse método é do tipo "breve", retornando a promessa instantaneamente. se os resultados fossem buscados em um servidor, isso não seria uma opção, e o processo levaria algum tempo.

Nos componentes, também precisamos reescrever o código de forma que, ao invés de receberem diretamente os dados, eles passem a receber promessas.
Como exemplo, no componente menu, tínhamos o dishService retornando um vetor de objetos dishes. Agora, esse service deve retornar os resultados da promessa, utilizando o método "then".
    ngOnInit() {
        this.dishService.getDishes()
        .then(dishes => this.dishes = dishes);
    }
    //o resultado da promessa é um vetor de dishes, passado como parâmetro, e ao qual a arrow function atribui this dishes.

Até aqui, utlizamos um abordagem para retornar as promessas instantaneamente. Em aplicações reais, no entanto, os dados não são ofertados imediatamente. O service precisa buscar a informação no servidor back-end, e isso leva algum tempo.
Altermos no projeto as promessas, conforme o exemplo abaixo.
    getDishes(): Promise<Dish[]> {
        return new Promise(resolve=> {
        resolve(DISHES);
        });
    }

Considerando agora o delay, podemos manter o usuário informado sobre o fato de que a informação está sendo buscada e é necessário esperar o processo, exibindo algum conteúdo visual que represente esse tempo de espera.
Em nosso projeto, implementamos um componente do Angular Material, spinner progress, que exibe um disco giratório no template view enquanto os dados estão sendo carregados.
Importar o module ProgressSpinner no appmodule e incluir no imports.
    import { MatProgressSpinnerModule } from '@angular/material/progress-spinner';

No componente menu, se adicionarmos ao menu dos pratos a diretiva *ngIf="dishes" , estaremos forçando que os dados sejam exibidos apenas quando o valor dos objetos dishes sejam conhecidos - isto é, a promise terá que ser resolvida antes. 
Inserimos também o spinner em um div [hidden] para indicar que, quando o valor de dishes é conhecido, este div não será exibido. Caso contrário, o spinner estará visível.
  <div [hidden]="dishes">
    <mat-spinner></mat-spinner><h4>Loading . . . Please Wait</h4>
Em suma, o menu só aparecerá quando esse processo finalizar; enquanto isso, o spinner aparecerá na tela.


ANGULAR AND RXJS

A biblioteca RxJS fornece uma opção para escrever com programação reativa nas aplicações Angular.
A programação reativa gira em torno do padrão de engenharia de software chamado Observer. Nele, fazemos uso de observables cujo comportamento é monitorado por observers.
Declaramos objetos como observados ou sujeitos que serão monitorados pelos observadores. Os observadores monitoram as alterações, sendo que os observados notificam os observadores quando da ocorrência de alterações.
Esse padrão é baseado na concepção de que os dados fluem como correntes através da aplicação, é possível inscrever-se a essa correnteza e pegar dela determinados valores e responder a eles. Os observados emitem valores e os observadores reagem a eles.
Inscrevemos (subscribe) um observador para observar um observado através de: .subscribe() . A partir daí, o observado informa o observador interessado sobre os valores.
É possível também determinar o cancelamento ou a revisão do ato de pegar dados de uma observado.
Na programação reativa, estamos interessados em como os dados fluem pela aplicação. O fluxo é tratado como uma correnteza, de forma que uma mudança pode ser propagada ao longo da aplicação. Uma corrente que entra pode sofrer modificações e criar uma corrente de saída já alterada.

RxJS é uma implementação JavaScript do padrão de projeto Observer e suporte à programação reativa. É uma biblioteca para compor programas com assincronia (callbacks) e baseados em eventos, utilizando sequências de observados. O Angular suporta RxJS.
RxJS fornece:
    um tipo principal, o Observable;
    tipos satélites: Observer, Schedulers, Subjects;
    operadores: inspirados nos operados de vetores JS, como map, filter, reduce, every, etc.;
    os valores dos observados são tomados como sequências de vetores, o que permite lidar com eventos assíncronos sob a forma de coleções.
